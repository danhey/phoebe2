#!/usr/bin/python

"""
pip install flask
pip install flask-sqlalchemy
pip install flask-socketio
pip install gevent-websocket

mpltracker https://github.com/kecnry/mpltracker


to launch with MPI enabled:
PHOEBE_ENABLE_MPI=TRUE PHOEBE_MPI_NP=8 phoebe-server
"""

try:
    from flask import Flask, jsonify, request, redirect, make_response, send_from_directory
    from flask_socketio import SocketIO, emit, join_room, leave_room
    #import flask.ext.sqlalchemy
except ImportError:
    raise ImportError("dependencies not met: pip install flask flask-sqlalchemy flask-socketio gevent-websocket")

################################ SERVER/APP SETUP ##############################


app = Flask(__name__)
app._bundles = {}
app._clients = []
app._verbose = True
app._killable = False

# we'll disable sorting the responses by keys so that we can control the sorting
# by qualifier instead of uniqueid.  This will sacrifice caching ability in the
# browser unless we set the order of all keys to be consistent.
app.config['JSON_SORT_KEYS'] = False

# Create the Flask-SQLAlchemy object and an SQLite database
# app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///phoebe.db'
# db = flask.ext.sqlalchemy.SQLAlchemy(app)

# Configure socket.io
app.config['SECRET_KEY'] = 'phoebesecret'
socketio = SocketIO(app)

def _uniqueid(N=16):
    """
    :parameter int N: number of character in the uniqueid
    :return: the uniqueid
    :rtype: str
    """
    return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase) for _ in range(N))

def _new_bundleid(N=6):
    """
    will have 52**N uniqueids available.  But we'll check for duplicates just to
    make sure.
    """
    uniqueid = _uniqueid(N=N)
    if uniqueid not in app._bundles.keys():
        return uniqueid
    else:
        # you should really enter the lottery, unless N is <= 3
        return _new_bundleid(N=N)

################################## ADDITIONAL IMPORTS ##########################

import mpltracker  # https://www.github.com/kecnry/mpltracker
import phoebe
import numpy as np
import matplotlib.pyplot as plt
import json
import random
import string
import os
import sys
import tempfile
import traceback
import StringIO
from time import sleep
from collections import OrderedDict
from datetime import datetime # debug only


phoebe.interactive_off()
phoebe.parameters._is_server = True

# logger = phoebe.logger('INFO')
_dir_tmpimages = os.path.join(tempfile.gettempdir(), 'phoebe-server-tmpimages')

if not os.path.exists(_dir_tmpimages):
    os.makedirs(_dir_tmpimages)


# TODO: can we also process and emit logger signals (https://docs.python.org/2/library/logging.handlers.html#sockethandler)?  Or at the least we could call b.run_checks after each command manually and broadcast those messages

###############################################################################
# We need to tell clients that its ok to accept API information from an external
# server since this will almost always be running from a different URL/port
# than the client.
# The following code that accomplishes this is taken (borrowed) almost entirely
# from http://flask.pocoo.org/snippets/56/
from datetime import timedelta
from flask import make_response, request, current_app
from functools import update_wrapper


def crossdomain(origin=None, methods=None, headers=None,
                max_age=21600, attach_to_all=True,
                automatic_options=True):
    if methods is not None:
        methods = ', '.join(sorted(x.upper() for x in methods))
    if headers is not None and not isinstance(headers, basestring):
        headers = ', '.join(x.upper() for x in headers)
    if not isinstance(origin, basestring):
        origin = ', '.join(origin)
    if isinstance(max_age, timedelta):
        max_age = max_age.total_seconds()

    def get_methods():
        if methods is not None:
            return methods

        options_resp = current_app.make_default_options_response()
        return options_resp.headers['allow']

    def decorator(f):
        def wrapped_function(*args, **kwargs):
            if automatic_options and request.method == 'OPTIONS':
                resp = current_app.make_default_options_response()
            else:
                resp = make_response(f(*args, **kwargs))
            if not attach_to_all and request.method != 'OPTIONS':
                return resp

            h = resp.headers

            h['Access-Control-Allow-Origin'] = origin
            h['Access-Control-Allow-Methods'] = get_methods()
            h['Access-Control-Max-Age'] = str(max_age)
            if headers is not None:
                h['Access-Control-Allow-Headers'] = headers
            return resp

        f.provide_automatic_options = False
        return update_wrapper(wrapped_function, f)
    return decorator

############################ BUNDLE MANIPULATION ###############################

def _value_string(param):
    param_type = param.__class__.__name__

    if param_type in ['StringParameter', 'ChoiceParameter', 'HierarchyParameter']:
        return param.get_value()
    elif param_type in ['ConstraintParameter']:
        return "(Constraint)"
    elif param_type in ['JobParameter']:
        return param.get_status()
    elif param_type in ['UnitParameter']:
        return str(param.get_value().to_string())
    elif param_type in ['IntParameter', 'DictParameter', 'BoolParameter']:
        return str(param.get_value())
    elif param_type in ['FloatParameter']:
        return str(param.get_value())
    elif param_type in ['FloatArrayParameter']:
        if isinstance(param._value, phoebe.dependencies.nparray.nparray.ArrayWrapper):
            return param._value.__str__()
        else:
            arr = param.get_value()
            # unit = str(param.get_default_unit())
            if len(arr):
                return "[{} ... {} ({})]".format(arr[0], arr[-1], len(arr))
            else:
                return "[] (empty)"
    else:
        return '({})'.format(param_type)

def _param_json_overview(param):
    p = {'uniqueid': param.uniqueid,
         'class': param.__class__.__name__,
         'valuestr': _value_string(param),
         'readonly': param.context in ['model'] or param.qualifier in ['phoebe_version'],
         }

    advanced_filter = []
    if not param.is_visible:
        advanced_filter.append('not_visible')
    if '_default' in [param.component, param.dataset]:
        advanced_filter.append('is_default')
    if param.advanced:
        advanced_filter.append('is_advanced')
    if hasattr(param, 'choices') and len(param.choices) <= 1:
        advanced_filter.append('is_single')
    if param.context=='constraint':
        advanced_filter.append('is_constraint')

    p['advanced_filter'] = advanced_filter


    for k,v in param.meta.items():
        if k in ['time', 'history', 'fitting', 'feedback', 'plugin']:
            continue
        p[k] = v

    return p

def _param_json_detailed(param):
    p  = {'description': param.description}

    if param.__class__.__name__ == 'ConstraintParameter':
        p['related_to'] = {p.uniqueid: p.twig for p in param.vars.to_list()}
        p['constraint'] = {}
        p['constrains'] = {p.uniqueid: p.twig for p in [param.constrained_parameter]}
    else:
        p['related_to'] = {p.uniqueid: p.twig for p in param.related_to} if hasattr(param, 'related_to') else {}
        p['constraint'] = {p.uniqueid: p.twig for p in [param.is_constraint]} if hasattr(param, 'is_constraint') and param.is_constraint is not None else {}
        p['constrains'] = {p.uniqueid: p.twig for p in param.constrains} if hasattr(param, 'constrains') else {}

    if hasattr(param, 'limits'):
        if hasattr(param, 'default_unit'):
            p['limits'] = [l.to(param.default_unit).value if l is not None else None for l in param.limits] + [param.default_unit.to_string()]
        else:
            p['limits'] = param.limits + [None]
    else:
        p['limits'] = None

    return p



############################ HTTP ROUTES ######################################
def _get_response(data, status_code=200, included=None, api=False, **metawargs):
    d = {}
    d['data'] = data
    d['meta'] = metawargs
    if included is not None:
        d['included'] = included
    if api:
        resp = jsonify(d)
        resp.status_code = status_code
        return resp
    else:
        return d

@app.route("/info", methods=['GET'])
@crossdomain(origin='*')
def test():
    # TODO: include version info?
    if app._verbose:
        print("info", phoebe.__version__, app._parent)
    return _get_response({'success': True, 'phoebe_version': phoebe.__version__, 'parentid': app._parent}, api=True)

@app.route('/new_bundle/<string:type>', methods=['GET'])
@crossdomain(origin='*')
def new_bundle(type):
    """
    Initiate a new bundle object, store it to local memory, and return the bundleid.
    The client is then responsible for making an additional call to access parameters, etc.

    type: 'binary:detached'
    """
    if app._verbose:
        print("new_bundle(type={})".format(type))

    def _new_bundle(constructor, **kwargs):
        try:
            b = getattr(phoebe, constructor)(**kwargs)
        except Exception as err:
            return _get_response({'success': False, 'error': str(err)}, api=True)
        else:
            bundleid = _new_bundleid()
            app._bundles[bundleid] = b
            return _get_response({'success': True, 'bundleid': bundleid}, api=True)

    if type == 'single':
        return _new_bundle('default_star')
    elif type == 'binary:detached':
        return _new_bundle('default_binary')
    # elif type == 'binary:detached:primary':
        # return _new_bundle('default_binary', semidetached='primary')
    # elif type == 'binary:detached:secondary':
        # return _new_bundle('default_binary', semidetached='secondary')
    elif type == 'binary:contact':
        return _new_bundle('default_binary', contact_binary=True)
    # elif type == 'triple:12:detached':
    #     return _new_bundle('default_triple', inner_as_primary=False, inner_as_contact=False)
    # elif type == 'triple:12:contact':
    #     return _new_bundle('default_triple', inner_as_primary=False, inner_as_contact=True)
    # elif type == 'triple:21:detached':
    #     return _new_bundle('default_triple', inner_as_primary=True, inner_as_contact=False)
    # elif type == 'triple:21:contact':
    #     return _new_bundle('default_triple', inner_as_primary=True, inner_as_contact=True)
    else:
        return _get_response({'success': False, 'error': 'bundle with type "{}" not implemented'.format(type)}, api=True)

@app.route('/bundle/<string:bundleid>', methods=['GET'])
@crossdomain(origin='*')
def bundle(bundleid):
    """
    """
    if app._verbose:
        print("bundle(bundleid={})".format(bundleid))

    def sort(group, tags):
        if group=='contexts':
            # try to order contexts in same order as shown in UI.. then fill in with the rest
            lst = [k for k in ['constraint', 'component', 'feature', 'dataset', 'figure', 'compute', 'model'] if k in tags]
            for k in tags:
                if k not in lst:
                    lst.append(k)
            return lst
        else:
            return sorted(tags)


    if bundleid not in app._bundles.keys():
        return _get_response({'success': False, 'error': 'bundle not found with bundleid={}'.format(bundleid)}, api=True)

    b = app._bundles.get(bundleid)

    param_list = sorted([_param_json_overview(param) for param in b.to_list()], key=lambda p: p['qualifier'])
    param_dict = OrderedDict((p.pop('uniqueid'), p) for p in param_list)

    tags = {k: sort(k, v) for k,v in b.tags.items()}

    return _get_response({'success': True, 'parameters': param_dict, 'tags': tags}, api=True)

@app.route('/parameter/<string:bundleid>/<string:uniqueid>', methods=['GET'])
@crossdomain(origin='*')
def parameter(bundleid, uniqueid):
    """
    """
    if app._verbose:
        print("parameter(bundleid={}, uniqueid={})".format(bundleid, uniqueid))

    if bundleid not in app._bundles.keys():
        return _get_response({'success': False, 'error': 'bundle not found with bundleid={}'.format(bundleid)}, api=True)

    b = app._bundles.get(bundleid)

    try:
        param = b.get_parameter(uniqueid=uniqueid)
    except:
        return _get_response({'success': False, 'error': 'could not find parameter with uniqueid={}'.format(uniqueid)}, api=True)

    data = _param_json_detailed(param)

    return _get_response({'success': True, 'parameter': data}, api=True)


# @app.route("/clients", methods=['GET'])
# @crossdomain(origin='*')
# def clients():
#     if app._verbose:
#         print("clients", app._clients)
#
#     return _get_response({'success': True, 'clients': app._clients}, api=True)

# @app.route("/<string:bundleid>/json", methods=['GET'])
# @crossdomain(origin='*')
# def get_json(bundleid):
#     if app._verbose:
#         print("GET request for json")
#
#     b = app._bundles[bundleid]
#
#     data = b.to_json(incl_uniqueid=True)
#
#     #print "returning json response"
#     return _get_response(data, bundleid=bundleid, api=True)

# @app.route("/<string:bundleid>/figure/<string:figure>", methods=['GET'])
# def serve_figure(bundleid, figure):
#     fname = '{}_{}.png'.format(bundleid, figure)
#     if app._verbose:
#         print("serve_figure", fname)
#     return send_from_directory(_dir_tmpimages, fname)

# @app.route("/<string:bundleid>/figure_mpl/<string:figure>", methods=['GET'])
# def serve_figure_mpl(bundleid, figure):
#     fname = '{}_{}.mpl'.format(bundleid, figure)
#     if app._verbose:
#         print("serve_figure_mpl", fname)
#     return send_from_directory(_dir_tmpimages, fname)


############################# WEBSOCKET ROUTES ################################
def _value(param, exclude_model=False):

    if isinstance(param._value, phoebe.dependencies.nparray.nparray.ArrayWrapper):
        value = param._value.to_json()
    elif isinstance(param, phoebe.parameters.UnitParameter):
        value = str(param.get_value().to_string())
    else:
        value = param.get_value()

    if isinstance(value, np.ndarray):
        # TODO: for now we always truncate the values for these big arrays... but
        # the python client will need the actual data or a way to poll for it
        if (exclude_model or True) and param.context == 'model':
            #then it'll be read only (for the desktop-client)
            value = None
        else:
            value = value.tolist()

    return value


def _params(b, ps=None, includeids=[], check_visible=True, check_default=False,
            check_advanced=False, check_single=False,
            subtract_constraint=False, sort_by='qualifier', exclude_model=False,
            **filter_):
    def _unitchoices(unit):
        physical_type = unit.physical_type

        if physical_type == 'dimensionless':
            if unit.to_string() in ['', 'dimensionless']:
                pass
            else:
                physical_types = [un.physical_type for un in unit.bases]
                if all([pt=='time' for pt in physical_types]):
                    # then we're time/time, eg. s / yr
                    # NOTE: doing same units on numerator and denominator will force this to be dimensionless
                    # and then we won't know that its time at all.
                    return ['d / yr', 'h / d', 'h / yr', 'min / d', 'min / h', 'min / yr', 's / min', 's / h', 's / d', 's / yr']
                else:
                    return [unit.to_string()]
        elif physical_type == 'time':
            return ['yr', 'd', 'h', 'min', 's']
        elif physical_type == 'mass':
            return ['solMass', 'jupiterMass', 'earthMass', 'kg', 'g']
        elif physical_type == 'length':
            return ['solRad', 'jupiterRad', 'earthRad', 'AU', 'pc', 'km', 'm', 'cm']
        elif physical_type == 'area':
            return ['solRad2', 'jupiterRad2', 'earthRad2', 'AU2', 'pc2', 'km2', 'm2', 'cm2']
        elif physical_type == 'volume':
            return ['solRad3', 'jupiterRad3', 'earthRad3', 'AU3', 'pc3', 'km3', 'm3', 'cm3']
        elif physical_type == 'speed':
            return ['solRad / d', 'solRad / s', 'km / h', 'km / s', 'm / h', 'm / s']
        elif physical_type == 'angle':
            return ['rad', 'deg']
        elif physical_type == 'angular speed':
            return ['rad / yr', 'rad / d', 'rad / h', 'rad / s', 'deg / yr', 'deg / d', 'deg / h', 'deg / s']
        elif physical_type == 'temperature':
            # astropy cannot convert to u.deg_C or u.imperial.deg_F
            return ['K']
        else:
            return [unit.to_string()]

    def _choices(parameter):
        if hasattr(parameter, 'choices'):
            return parameter.choices
        elif parameter.__class__.__name__ == 'BoolParameter':
            return ['True', 'False']
        elif parameter.__class__.__name__ == 'UnitParameter':
            return _unitchoices(parameter.get_value())
        else:
            return None


    if ps is None:
        ps = b.filter(check_visible=check_visible, check_default=check_default,
                      check_advanced=check_advanced, check_single=check_single, **filter_)
    elif isinstance(ps, list):
        ps = phoebe.parameters.ParameterSet(ps)
    elif isinstance(ps, phoebe.Parameter):
        ps = phoebe.parameters.ParameterSet([ps])
    elif not isinstance(ps, phoebe.ParameterSet):
        raise TypeError("ps must be of type ParameterSet not {}".format(type(ps)))

    if subtract_constraint:
        ps -= ps.filter(context='constraint')

    if len(includeids):
        ps += b.filter(check_visible=False, check_default=False,
                       check_advanced=False, check_single=False,
                       uniqueid=includeids)

    ps += phoebe.parameters.ParameterSet(b.run_delayed_constraints())
    nparams = len(ps)
    params = ps.to_dict(field=sort_by, include_none=True)  # key, PS

    for k, ps in params.items():
        this_params = {}
        for p in ps.to_list():
            typ = p.__class__.__name__
            pdict = {'twig': p.uniquetwig, 'uniqueid': p.uniqueid, 'valuestr': _value_string(p), 'type': typ, 'attributes': {'value': _value(p, exclude_model=exclude_model)}}
            pdict['meta'] = p.meta
            pdict['readonly'] = p.context in ['model'] or p.qualifier in ['phoebe_version']

            pdict['choices'] = _choices(p)

            if hasattr(p, 'is_constraint'):
                pdict['constrained'] = p.is_constraint is not None

            if hasattr(p, 'default_unit'):
                pdict['valueunit'] = p.default_unit.to_string()

                # NOTE: if any of these should be converted to an html form in the
                # desktop app, those cases need to be explicitly defined in parameters.jsx
                pdict['unitchoices'] = _unitchoices(p.default_unit)
            else:
                pdict['valueunit'] = None
                # pdict['unitchoices'] = False

            # if app._verbose:
                # print pdict

            this_params[p.uniqueid] = pdict

        params[k] = this_params

    return params, nparams

########## SOCKET ERRORS
@socketio.on_error()
def error_handler(err):
    print("websocket error:", err)

    if app._verbose:
        ex_type, ex, tb = sys.exc_info()
        print traceback.print_tb(tb)

    emit('msg', {'success': False, 'id': None, 'level': 'error', 'msg': 'websocket: '+err.message}, broadcast=False)



########## CLIENT MANAGEMENT
@socketio.on('connect')
def connect():
    if app._verbose:
        print('Client connected')

    # emit('connect', {'success': True, 'data': {'clients': app._clients, 'parentid': app._parent}})

@socketio.on('disconnect')
def disconnect():
    if app._verbose:
        print('Client disconnected')

    # emit('disconnect', {'success': True, 'data': {'clients': app._clients, 'parentid': app._parent}})

@socketio.on('test')
def ping(msg=None):
    if app._verbose:
        print("received test msg:", msg)

    emit('test response', {'success': True, 'data': 'pong'}, broadcast=False)

@socketio.on('echo')
def echo(msg=None):
    if app._verbose:
        print("echo", msg)

    echo = msg.pop('echo', 'echo')
    emit(echo, msg, broadcast=False)

@socketio.on('register client')
def register_client(msg):
    clientid = msg.get('clientid', None)
    if app._verbose:
        print("Client registered: ", clientid)

    if clientid is not None and clientid not in app._clients:
        app._clients.append(clientid)

    emit('clients changed', {'success': True, 'data': {'clients': app._clients, 'parentid': app._parent}}, broadcast=True)

@socketio.on('deregister client')
def deregister_client(msg):
    clientid = msg.get('clientid', None)
    if app._verbose:
        print("Client deregisterd: ", clientid)

    if clientid is not None:
        app._clients.remove(clientid)

    emit('clients changed', {'success': True, 'data': {'clients': app._clients, 'parentid': app._parent}}, broadcast=True)



########## PARAMETERS
@socketio.on('set_value')
def set_value(msg):
    if app._verbose:
        print("set_value: ", msg)

    packetid = msg.pop('id', None)

    bundleid = msg.pop('bundleid')
    b = app._bundles[bundleid]

    while b._lock:
        sleep(0.25)
    b._lock = True

    try:
        b.set_value_all(**msg)
    except Exception as err:
        if app._verbose:
            print("set_value {} error: {}".format(msg, err.message))
        b._lock=False
        emit('msg', {'success': False, 'id': packetid, 'level': 'error', 'msg': err.message}, broadcast=False)
    else:

        # now let's send a broadcast message to all subscribed clients with a list of ALL changes (note the redundancy for the original client)
        changes, nparams = _params(b, **msg)

        filteredps = b.filter(check_visible=False, check_default=False,
                              check_advanced=False, check_single=False, **msg)
        figureschanged = b.figures if filteredps.context=='figure' and not len(filteredps.figures) else filteredps.figures

        b._lock=False
        emit('set_value', {'success': True, 'id': packetid, 'data': {'bundleid': bundleid, 'changes': changes, 'figureschanged': figureschanged}}, broadcast=True)

        passing, warning = b.run_checks()
        if not passing:
            emit('msg', {'success': True, 'id': packetid, 'level': 'warning', 'msg': warning}, broadcast=False)

@socketio.on('set_default_unit')
def set_default_unit(msg):
    if app._verbose:
        print("set_default_unit: ", msg)

    packetid = msg.pop('id', None)

    bundleid = msg.pop('bundleid')
    b = app._bundles[bundleid]

    while b._lock:
        sleep(0.25)
    b._lock = True

    try:
        b.set_default_unit_all(**msg)
    except Exception as err:
        if app._verbose:
            print("set_default_unit {} error: {}".format(msg, err.message))
        b._lock = False
        emit('msg', {'success': False, 'id': packetid, 'level': 'error', 'msg': err.message}, broadcast=False)
    else:
        # params = b.filter(**msg).to_list()

        changes, nparams = _params(b, **msg)

        b._lock = False
        # TODO: this may be overkill
        emit('set_value', {'success': True, 'id': packetid, 'data': {'bundleid': bundleid, 'changes': changes}}, broadcast=True)

@socketio.on('bundle_method')
def bundle_method(msg):
    if app._verbose:
        print("bundle_method: ", msg)

    packetid = msg.pop('id', None)

    bundleid = msg.pop('bundleid')
    b = app._bundles[bundleid]

    while b._lock:
        sleep(0.25)
    b._lock = True

    fctn = msg.pop('fctn')
    args = msg.pop('args', [])

    try:
        # let's not pass None on in kwargs as that can conflict with setdefault within phoebe
        method_kwargs = {k:v for k,v in msg.items() if v not in [None, '']}
        if 'run_' in fctn:
            if app._verbose:
                print "detach cmd: ", phoebe.conf.detach_cmd
            method_kwargs.setdefault('detach', True)
        if app._verbose:
            print("running b.{}(*{}, **{})".format(fctn, args, method_kwargs))
        params = getattr(b, fctn)(*args, **method_kwargs)

        # print "***", params

        # handle the case where there are no changes by mocking an empty PS
        if params is None:
            if app._verbose:
                print("return was None, mocking empty PS")
            params = phoebe.parameters.ParameterSet([])

    except Exception as err:
        if app._verbose:
            print("bundle_method fctn={} args={} kwargs={} error={}".format(fctn, args, msg, err.message))
        b._lock = False
        emit('msg', {'success': False, 'id': packetid, 'level': 'error', 'msg': err.message}, broadcast=False)
    else:
        # print("params.length", len(params))
        # print("params.meta", params.meta)

        newparamsfilter = {k: [v] for k,v in params.meta.items() if v is not None and k not in ['twig', 'uniquetwig']}
        # print "*** newparamsfilter", newparamsfilter
        changes, nparams = _params(b, ps=params)
        # print "*** changes", changes

        if 'add_' in fctn or 'run_' in fctn:
            if 'run_' in fctn:
                newcontext = {'compute': 'model', 'model': 'model', 'fitting': 'feedback', 'feedback': 'feedback'}[fctn.split('_')[1]]
            else:
                newcontext = fctn.split('_')[1]

            newparamsfilter = {newcontext: [params.meta[newcontext]]}
        else:
            # TODO: check to see if this is what we want
            newcontext = None
            newparamsfilter = {}

        if app._verbose:
            print("bundle_method newparamsfilter: ", newparamsfilter)

        b._lock = False
        # if fctn in ['run_compute', 'run_fitting']:
            # newparamsattach  = params.uniqueid
        # else:
            # newparamsattach = False

        if 'run_' in fctn:
            # then we have a new pending job
            pendingjob = params.uniqueid
        else:
            pendingjob = None

        # TODO: this may be overkill
        emit('set_value', {'success': True, 'id': packetid, 'data': {'bundleid': bundleid, 'changes': changes, 'newparams': True, 'newparamscontext': newcontext, 'newparamsfilter': newparamsfilter, 'addjob': pendingjob}}, broadcast=True)


@socketio.on('attach')
def attach(msg):
    if app._verbose:
        print("attach: ", msg)

    packetid = msg.pop('id', None)

    bundleid = msg.pop('bundleid')
    b = app._bundles[bundleid]

    uniqueid = msg.pop('uniqueid')

    try:
        status_param = b.get_parameter(uniqueid=uniqueid)
    except Exception as err:
        emit('msg', {'success': False, 'id': packetid, 'level': 'error', 'msg': err.message}, broadcast=False)
        return

    # now enter status loop
    # while status_param.status not in ['complete', 'loaded']:
        # if app._verbose:
            # print "checking job status..."
        # changes = _params(b, **newparamsfilter)
        # emit('set_value', {'success': True, 'id': packetid, 'data': {'bundleid': bundleid, 'changes': changes, 'newparams': False}}, broadcast=False)
        # sleep(5)

    while b._lock:
        sleep(0.25)
    b._lock = True

    try:
        params = status_param.attach(wait=False)
    except Exception as err:
        b._lock = False
        emit('msg', {'success': False, 'id': packetid, 'level': 'error', 'msg': err.message}, broadcast=False)
        return

    if isinstance(params, str):
        # then update the status of the job parameter
        newparamsfilter = {'uniqueid': uniqueid}
        changes, nparams = _params(b, **newparamsfilter)
        newparams = False
        newcontext = False
        newparamsfilter = False
        status = params
        removejob = None
        broadcast = False

    else:
        # then update with the new model
        newparamsfilter = {k: [v] for k,v in params.meta.items() if v is not None and k not in ['twig', 'uniquetwig']}
        newparams = True
        newcontext = status_param.context
        changes, nparams = _params(b, **newparamsfilter)
        status = 'loaded'
        broadcast = True


    if status == 'loaded':
        removejob = status_param.uniqueid

    b._lock = False

    print "*** attach set_value sending:", status, nparams, removejob

    emit('set_value', {'success': True, 'id': packetid, 'data': {'bundleid': bundleid, 'changes': changes, 'newparams': newparams, 'newparamscontext': newcontext, 'newparamsfilter': newparamsfilter, 'removejob': removejob}}, broadcast=broadcast)


@socketio.on('run_figure')
def run_figure(msg):
    if app._verbose:
        print("run_figure: ", msg)

    packetid = msg.pop('id', None)

    bundleid = msg.pop('bundleid')
    b = app._bundles[bundleid]

    figure = msg.pop('figure')

    fig = mpltracker.figure()
    b.run_figure(figure, ax=fig.gca())

    fname = '{}_{}.png'.format(bundleid, figure)
    fig.savefig(os.path.join(_dir_tmpimages, fname))
    furl = '{}/figure/{}'.format(bundleid, figure)

    try:
        tracker_fname = '{}_{}.mpl'.format(bundleid, figure)
        mpltracker.gct(fig).save(os.path.join(_dir_tmpimages, tracker_fname))
        tracker_furl = '{}/figure_mpl/{}'.format(bundleid, figure)
        mpltracker.close(fig)
    except:
        emit('msg', {'level': 'warning', 'msg': 'failed to build interactive plot'}, broadcast=False)
        tracker_furl = None


    emit('figureimage', {'success': True, 'id': packetid, 'data': {'url': furl, 'mplurl': tracker_furl}}, broadcast=False)


if __name__ == "__main__":
    #phoebe_server.py port, parent, host
    if len(sys.argv) >= 2:
        port = int(float(sys.argv[1]))
    else:
        port = 5555

    if len(sys.argv) >= 3:
        parent = sys.argv[2]
    else:
        parent = 'notprovided'

    if len(sys.argv) >=4:
        host = sys.argv[3]
    else:
        host = '127.0.0.1'

    app._parent = parent
    socketio.run(app, host=host, port=port)
